import pygame, sys, os
from pygame.locals import *
<<<<<<< HEAD
#import serial
import threading as t
import time

FLAG = True
dicc={'a':[[0, 544],[600, 512]]}
for i in xrange(100):
	dicc['a'].append([32*i,544])

# def controlArduino(jugador):
# 	global FLAG
# 	try:
# 		AR = serial.Serial('/dev/ttyACM0',9600)
# 	except:
# 		FLAG = False
# 	while FLAG:
# 		indicador = AR.readline().strip()
# 		if '1' in indicador:
# 			jugador['salto']=1

# 		elif '2' in indicador:
# 			jugador['salto']=0

# 		if '3' in indicador:
# 			jugador['direccion'] = 'R'

# 		elif '4' in indicador:
# 			jugador['direccion'] = 'N'
=======
import serial
import threading as t
from time import sleep

FLAG = True
dicc={'a':(0, 576-32)}
>>>>>>> 34d250abe1b85176bf78e4d49a1f1269ca9f8d0a

def controlArduino(jugador):
	global FLAG
	try:
		AR = serial.Serial('/dev/ttyACM0',9600)
	except:
		FLAG = False
	while FLAG:
		indicador = AR.readline().strip()
		if '1' in indicador:
			jugador['salto']=1

		elif '2' in indicador:
			jugador['salto']=0

		if '3' in indicador:
			jugador['direccion'] = 'R'

		elif '4' in indicador:
			jugador['direccion'] = 'N'

def resize(image, size):
	image=(pygame.image.load(os.path.join('data', image)))
	return pygame.transform.scale(image, size)

<<<<<<< HEAD
def moverPantalla(velHor,acelHor,bloques):
	velHor+=acelHor
	for i in bloques.values()[0]:
		i[0]-=velHor
	return None


=======
>>>>>>> 34d250abe1b85176bf78e4d49a1f1269ca9f8d0a
def mover(jugador, unidad, moment, sprites,noAvanzar):
	if jugador["direccion"] == 'R':
		if noAvanzar!='R':
			jugador["posicion"][0] += unidad
		if (moment/100)%2 == 0:
			jugador["sprite"] = 0
		else:
			jugador["sprite"] = 1
	if jugador["direccion"] == 'L':
		if noAvanzar!='L':
			jugador["posicion"][0] -= unidad
		if (moment/100)%2 == 0:
			jugador["sprite"] = 2
		else:
			jugador["sprite"] = 3


#--------------------------------------------------
clock       	= pygame.time.Clock()
Juego 			= 1 	#Variable booleana que determina si el bucle sigue
unidad 			= 4 	# Velocidad de movimiento
personaje 		= [] 	# Lista de sprites del personaje
bloques 		= [] 	# Lista de sprites de los bloques
<<<<<<< HEAD
acelHor			= 0
velHor			= 1
=======
>>>>>>> 34d250abe1b85176bf78e4d49a1f1269ca9f8d0a
jugador			= {
					"posicion":[0, 0],
					"gravedad":0,
					"vidas":3,
					"direccion":'N', 	#N=neutro, L=left, R=right
					"salto":0,
					"sprite":0 			#Indice del sprite en la lista de los sprites del personaje
					}
<<<<<<< HEAD
#arduinoProcess	= t.Thread(target=controlArduino,args=(jugador,))
=======
arduinoProcess	= t.Thread(target=controlArduino,args=(jugador,))
>>>>>>> 34d250abe1b85176bf78e4d49a1f1269ca9f8d0a
#Carga de sprites
background=resize('bg.png', (800, 600))
personaje.append(resize('koopa1.png', (32, 64)))  # Texturas hacia la derecha
personaje.append(resize('koopa2.png', (32, 64)))
personaje.append(pygame.transform.flip(resize('koopa1.png', (32, 64)), True, False)) #Texturas hacia la izquierda (derecha con flip)
personaje.append(pygame.transform.flip(resize('koopa2.png', (32, 64)), True, False))
bloques.append(resize('fg.png', (32, 32)))

pygame.init() #Inicializar pygame
window=pygame.display.set_mode((800, 576)) #Crea ventana 800x600
<<<<<<< HEAD
#arduinoProcess.start()
=======
arduinoProcess.start()
>>>>>>> 34d250abe1b85176bf78e4d49a1f1269ca9f8d0a

while Juego:		#Mainloop
	colisiones=[]
	clock.tick(60) #Se setea el maximo fps
	pygame.display.set_caption("NN | FPS: "+str(round(clock.get_fps(), 2))) # Con esto se imprime los fps en el nombre del archivo
	window.blit(background, (0, 0)) 													# Fondo del juego
	personajeRect=window.blit(personaje[jugador["sprite"]], jugador["posicion"])		# Texturas del jugador
	# for i in xrange(25):						#anadir Bloques a la ventana principal
	# 	x, y=dicc['a']
	# 	colisiones.append(window.blit(bloques[0], (x+i*32, y)))
	# colisiones.append(window.blit(bloques[0], (600, 512)))
	for i in dicc:
		for bloque in dicc[i]:
			colisiones.append(window.blit(bloques[0],(bloque[0],bloque[1])))

	pygame.display.update()


	for event in pygame.event.get():
		if event.type==pygame.QUIT:
			FLAG = False
<<<<<<< HEAD
			#time.sleep(5)
=======
			sleep(5)
>>>>>>> 34d250abe1b85176bf78e4d49a1f1269ca9f8d0a
			sys.exit()

		elif event.type==KEYDOWN:
			if event.key==K_RIGHT:
				jugador["direccion"] = "R"

			if event.key==K_LEFT:
				jugador["direccion"] = "L"

			if event.key==K_SPACE:
				jugador['salto'] = 1

		elif event.type==KEYUP:
			if event.key==K_RIGHT:
				jugador["direccion"] = "N"

			if event.key==K_LEFT:
				jugador["direccion"] = "N"

	noAvanzar = 0
	moment=pygame.time.get_ticks()
	listacolisiones = personajeRect.collidelistall(colisiones) #Lista con las colisiones que tiene el personaje

	if listacolisiones==[]:
		jugador['gravedad'] 	+= 1
		jugador["posicion"][1]	+= jugador['gravedad']

	else:
		for bloque in colisiones:
			x1,y1=jugador['posicion']
			x, y, l, a = bloque				# Coordenada X , coordenada Y, Longitud y altura
			if x1+a == x and (y <= y1 <= y1+a or y <= y1+a <= y1+a):
				noAvanzar='R'
			if x1==x+a and (y<=y1<=y1+a or y<=y1+a<=y1+a):
				noAvanzar='L'

		jugador['gravedad'] 	= 0
		jugador['posicion'][1] 	= (jugador["posicion"][1])/32*32+1 #Se le sumo uno porque antes rebotaba infinitamente

		if jugador['salto'] == 1:
			jugador['gravedad'] 	= -12
			jugador['posicion'][1] 	+= jugador["gravedad"]
			jugador['salto'] 		= 0

<<<<<<< HEAD
	if jugador['posicion'][0] > 800 or jugador ['posicion'][1]>600:
		jugador['posicion'] = [0,0]

	mover(jugador, unidad, moment, personaje, noAvanzar)

	if moment%100==0:
		acelHor += 1

	moverPantalla(velHor,acelHor,dicc)
=======
	if jugador['posicion'][0] > 800:
		jugador['posicion'] = [0,0]

	mover(jugador, unidad, moment, personaje, noAvanzar)
>>>>>>> 34d250abe1b85176bf78e4d49a1f1269ca9f8d0a
